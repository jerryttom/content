TDD 项目实战 70 讲 | 更新完结

全网it学习资源共享学习<br>全网课程都有，欢迎私聊<br>微信：jerryttom<br>

– ├──01｜TDD演示（1）：任务分解法与整体工作流程.md 6.23kb<br> – ├──01｜TDD演示（1）：任务分解法与整体工作流程.mp3 5.82M<br> – ├──01｜TDD演示（1）：任务分解法与整体工作流程.pdf 4.38M<br> – ├──02｜TDD演示（2）：识别坏味道与代码重构.md 7.54kb<br> – ├──02｜TDD演示（2）：识别坏味道与代码重构.mp3 4.79M<br> – ├──02｜TDD演示（2）：识别坏味道与代码重构.pdf 3.34M<br> – ├──03｜TDD演示（3）：按测试策略重组测试.md 6.99kb<br> – ├──03｜TDD演示（3）：按测试策略重组测试.mp3 5.98M<br> – ├──03｜TDD演示（3）：按测试策略重组测试.pdf 3.68M<br> – ├──04｜TDD演示（4）：实现对于列表参数的支持.md 6.57kb<br> – ├──04｜TDD演示（4）：实现对于列表参数的支持.mp3 6.55M<br> – ├──04｜TDD演示（4）：实现对于列表参数的支持.pdf 2.58M<br> – ├──05｜TDD中的测试（1）：状态验证为什么是主要的使用方式？.md 6.58kb<br> – ├──05｜TDD中的测试（1）：状态验证为什么是主要的使用方式？.mp3 7.15M<br> – ├──05｜TDD中的测试（1）：状态验证为什么是主要的使用方式？.pdf 3.46M<br> – ├──06｜TDD中的测试（2）：行为验证为什么应该尽量避免使用？.md 7.42kb<br> – ├──06｜TDD中的测试（2）：行为验证为什么应该尽量避免使用？.mp3 8.77M<br> – ├──06｜TDD中的测试（2）：行为验证为什么应该尽量避免使用？.pdf 3.33M<br> – ├──07｜TDD中的测试（3）：集成测试还是单元测试？.md 8.17kb<br> – ├──07｜TDD中的测试（3）：集成测试还是单元测试？.mp3 7.67M<br> – ├──07｜TDD中的测试（3）：集成测试还是单元测试？.pdf 2.15M<br> – ├──08｜TDD中的驱动（1）：驱动的极限是什么？.md 7.96kb<br> – ├──08｜TDD中的驱动（1）：驱动的极限是什么？.mp3 6.65M<br> – ├──08｜TDD中的驱动（1）：驱动的极限是什么？.pdf 2.83M<br> – ├──09｜TDD中的驱动（2）：重构发挥了什么作用？.md 6.19kb<br> – ├──09｜TDD中的驱动（2）：重构发挥了什么作用？.mp3 5.67M<br> – ├──09｜TDD中的驱动（2）：重构发挥了什么作用？.pdf 4.05M<br> – ├──10｜TDD中的驱动（3）：何为经典学派？何为伦敦学派？.md 6.06kb<br> – ├──10｜TDD中的驱动（3）：何为经典学派？何为伦敦学派？.mp3 5.04M<br> – ├──10｜TDD中的驱动（3）：何为经典学派？何为伦敦学派？.pdf 2.02M<br> – ├──11｜作为工程化方法的TDD：更低的成本与更高的效能.md 9.80kb<br> – ├──11｜作为工程化方法的TDD：更低的成本与更高的效能.mp3 8.24M<br> – ├──11｜作为工程化方法的TDD：更低的成本与更高的效能.pdf 3.39M<br> – ├──12｜实战中的TDD：RESTfulAPI的开发框架.md 3.09kb<br> – ├──12｜实战中的TDD：RESTfulAPI的开发框架.mp3 2.61M<br> – ├──12｜实战中的TDD：RESTfulAPI的开发框架.pdf 2.65M<br> – ├──13｜DIContainer（1）：如何实现基本的DI容器结构？.md 4.46kb<br> – ├──13｜DIContainer（1）：如何实现基本的DI容器结构？.mp3 2.11M<br> – ├──13｜DIContainer（1）：如何实现基本的DI容器结构？.pdf 2.08M<br> – ├──14｜DIContainer（2）：如何通过SadPath为容器增加功能？.md 3.36kb<br> – ├──14｜DIContainer（2）：如何通过SadPath为容器增加功能？.mp3 1.13M<br> – ├──14｜DIContainer（2）：如何通过SadPath为容器增加功能？.pdf 2.28M<br> – ├──15｜DIContainer（3）：如何重构已有的代码？.md 4.67kb<br> – ├──15｜DIContainer（3）：如何重构已有的代码？.mp3 1.26M<br> – ├──15｜DIContainer（3）：如何重构已有的代码？.pdf 2.35M<br> – ├──16｜DIContainer（4）：如何实现对循环依赖的处理？.md 3.09kb<br> – ├──16｜DIContainer（4）：如何实现对循环依赖的处理？.mp3 1.87M<br> – ├──16｜DIContainer（4）：如何实现对循环依赖的处理？.pdf 3.17M<br> – ├──17｜DIContainer（5）：API接口该怎么设计？.md 3.86kb<br> – ├──17｜DIContainer（5）：API接口该怎么设计？.mp3 1.58M<br> – ├──17｜DIContainer（5）：API接口该怎么设计？.pdf 2.08M<br> – ├──18｜DIContainer（6）：如何实现循环依赖的检查？.md 5.13kb<br> – ├──18｜DIContainer（6）：如何实现循环依赖的检查？.mp3 1.91M<br> – ├──18｜DIContainer（6）：如何实现循环依赖的检查？.pdf 2.44M<br> – ├──19｜DIContainer（7）：如何实现FieldInjection部分的功能？.md 6.52kb<br> – ├──19｜DIContainer（7）：如何实现FieldInjection部分的功能？.mp3 1.32M<br> – ├──19｜DIContainer（7）：如何实现FieldInjection部分的功能？.pdf 1.88M<br> – ├──20｜DIContainer（8）：如何实现MethodInjection部分的功能？.md 7.25kb<br> – ├──20｜DIContainer（8）：如何实现MethodInjection部分的功能？.mp3 854.80kb<br> – ├──20｜DIContainer（8）：如何实现MethodInjection部分的功能？.pdf 1.92M<br> – ├──21｜DIContainer（9）：怎样重构测试代码？.md 22.61kb<br> – ├──21｜DIContainer（9）：怎样重构测试代码？.mp3 1.47M<br> – ├──21｜DIContainer（9）：怎样重构测试代码？.pdf 2.01M<br> – ├──22｜DIContainer（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？.md 8.96kb<br> – ├──22｜DIContainer（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？.mp3 1.30M<br> – ├──22｜DIContainer（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？.pdf 1.40M<br> – ├──23｜DIContainer（11）：如何对ContainerTest进行文档化改造？.md 16.12kb<br> – ├──23｜DIContainer（11）：如何对ContainerTest进行文档化改造？.mp3 1.12M<br> – ├──23｜DIContainer（11）：如何对ContainerTest进行文档化改造？.pdf 1.18M<br> – ├──24｜DIContainer（12）：如何增补功能？.md 9.13kb<br> – ├──24｜DIContainer（12）：如何增补功能？.mp3 1.43M<br> – ├──24｜DIContainer（12）：如何增补功能？.pdf 1.20M<br> – ├──25｜DIContainer（13）：任务上的遗漏该怎么处理？.md 9.92kb<br> – ├──25｜DIContainer（13）：任务上的遗漏该怎么处理？.mp3 971.41kb<br> – ├──25｜DIContainer（13）：任务上的遗漏该怎么处理？.pdf 1.27M<br> – ├──26｜DIContainer（14）：如何重构对Type类型判断的逻辑？.md 11.83kb<br> – ├──26｜DIContainer（14）：如何重构对Type类型判断的逻辑？.mp3 1.35M<br> – ├──26｜DIContainer（14）：如何重构对Type类型判断的逻辑？.pdf 2.51M<br> – ├──27｜DIContainer（15）：如何封装类型判断逻辑？.md 11.49kb<br> – ├──27｜DIContainer（15）：如何封装类型判断逻辑？.mp3 1.12M<br> – ├──27｜DIContainer（15）：如何封装类型判断逻辑？.pdf 1.96M<br> – ├──28｜DIContainer（16）：行为封装会对测试产生什么影响？.md 11.72kb<br> – ├──28｜DIContainer（16）：行为封装会对测试产生什么影响？.mp3 990.06kb<br> – ├──28｜DIContainer（16）：行为封装会对测试产生什么影响？.pdf 2.47M<br> – ├──29｜DIContainer（17）：如何重构ContextConfig内部的实现？.md 14.31kb<br> – ├──29｜DIContainer（17）：如何重构ContextConfig内部的实现？.mp3 1.33M<br> – ├──29｜DIContainer（17）：如何重构ContextConfig内部的实现？.pdf 1.85M<br> – ├──30｜DIContainer（18）：如何增补依赖缺失和循环依赖的测试？.md 14.61kb<br> – ├──30｜DIContainer（18）：如何增补依赖缺失和循环依赖的测试？.mp3 1.63M<br> – ├──30｜DIContainer（18）：如何增补依赖缺失和循环依赖的测试？.pdf 1.95M<br> – ├──31｜DIContainer（19）：Qualifier部分的功能要如何完成？.md 15.17kb<br> – ├──31｜DIContainer（19）：Qualifier部分的功能要如何完成？.mp3 1.30M<br> – ├──31｜DIContainer（19）：Qualifier部分的功能要如何完成？.pdf 2.27M<br> – ├──32｜DIContainer（20）：如何对代码和测试进行重构？.md 15.95kb<br> – ├──32｜DIContainer（20）：如何对代码和测试进行重构？.mp3 2.06M<br> – ├──32｜DIContainer（20）：如何对代码和测试进行重构？.pdf 2.27M<br> – ├──33｜DIContainer（21）：如何处理Singleton生命周期部分的功能？.md 16.21kb<br> – ├──33｜DIContainer（21）：如何处理Singleton生命周期部分的功能？.mp3 1.35M<br> – ├──33｜DIContainer（21）：如何处理Singleton生命周期部分的功能？.pdf 2.06M<br> – ├──34｜DIContainer（22）：如何对Bind的逻辑进行重构？.md 18.64kb<br> – ├──34｜DIContainer（22）：如何对Bind的逻辑进行重构？.mp3 1.26M<br> – ├──34｜DIContainer（22）：如何对Bind的逻辑进行重构？.pdf 1.80M<br> – ├──35｜DIContainer（23）：项目回顾与总结.md 30.30kb<br> – ├──35｜DIContainer（23）：项目回顾与总结.mp3 4.27M<br> – ├──35｜DIContainer（23）：项目回顾与总结.pdf 3.71M<br> – ├──36｜实战中的TDD：RESTfulWebServices.md 4.10kb<br> – ├──36｜实战中的TDD：RESTfulWebServices.mp3 1.67M<br> – ├──36｜实战中的TDD：RESTfulWebServices.pdf 1.07M<br> – ├──37｜RESTfulWebServices（1）：明确架构愿景与架构组件间的交互.md 5.10kb<br> – ├──37｜RESTfulWebServices（1）：明确架构愿景与架构组件间的交互.mp3 5.26M<br> – ├──37｜RESTfulWebServices（1）：明确架构愿景与架构组件间的交互.pdf 3.16M<br> – ├──38｜RESTfulWebServices（2）：根据Spike的结果，要如何调整架构愿景？.md 2.44kb<br> – ├──38｜RESTfulWebServices（2）：根据Spike的结果，要如何调整架构愿景？.mp3 1.51M<br> – ├──38｜RESTfulWebServices（2）：根据Spike的结果，要如何调整架构愿景？.pdf 1.05M<br> – ├──39｜RESTfulWebServices（3）：明确架构愿景与调用栈顺序.md 3.07kb<br> – ├──39｜RESTfulWebServices（3）：明确架构愿景与调用栈顺序.mp3 1.59M<br> – ├──39｜RESTfulWebServices（3）：明确架构愿景与调用栈顺序.pdf 2.01M<br> – ├──40｜RESTfulWebServices（4）：在当前架构愿景下，要如何分解任务？.md 7.30kb<br> – ├──40｜RESTfulWebServices（4）：在当前架构愿景下，要如何分解任务？.mp3 4.29M<br> – ├──40｜RESTfulWebServices（4）：在当前架构愿景下，要如何分解任务？.pdf 3.35M<br> – ├──41｜RESTfulWebServices（5）：如何通过对数据测试的管理来凸显意图？.md 3.25kb<br> – ├──41｜RESTfulWebServices（5）：如何通过对数据测试的管理来凸显意图？.mp3 1.51M<br> – ├──41｜RESTfulWebServices（5）：如何通过对数据测试的管理来凸显意图？.pdf 2.41M<br> – ├──42｜RESTfulWebServices（6）：如何处理JAX-RS定义的异常类？.md 3.69kb<br> – ├──42｜RESTfulWebServices（6）：如何处理JAX-RS定义的异常类？.mp3 1.16M<br> – ├──42｜RESTfulWebServices（6）：如何处理JAX-RS定义的异常类？.pdf 1.87M<br> – ├──43｜RESTfulWebServices（7）：剩下两个SadPath场景该如何处理？.md 4.11kb<br> – ├──43｜RESTfulWebServices（7）：剩下两个SadPath场景该如何处理？.mp3 982.00kb<br> – ├──43｜RESTfulWebServices（7）：剩下两个SadPath场景该如何处理？.pdf 1.93M<br> – ├──44｜RESTfulWebServices（8）：如何在现有代码的基础上构造测试？.md 5.04kb<br> – ├──44｜RESTfulWebServices（8）：如何在现有代码的基础上构造测试？.mp3 1.42M<br> – ├──44｜RESTfulWebServices（8）：如何在现有代码的基础上构造测试？.pdf 2.07M<br> – ├──45｜RESTfulWebServices（9）：通过伦敦学派得到的测试风格是什么样的？.md 18.19kb<br> – ├──45｜RESTfulWebServices（9）：通过伦敦学派得到的测试风格是什么样的？.mp3 1.41M<br> – ├──45｜RESTfulWebServices（9）：通过伦敦学派得到的测试风格是什么样的？.pdf 2.27M<br> – ├──46｜RESTfulWebServices（10）：伦敦学派与经典学派的测试节奏有何不同？.md 8.82kb<br> – ├──46｜RESTfulWebServices（10）：伦敦学派与经典学派的测试节奏有何不同？.mp3 2.17M<br> – ├──46｜RESTfulWebServices（10）：伦敦学派与经典学派的测试节奏有何不同？.pdf 2.64M<br> – ├──47｜RESTfulWebServices（11）：如何通过Spike来验证架构愿景？.md 2.26kb<br> – ├──47｜RESTfulWebServices（11）：如何通过Spike来验证架构愿景？.mp3 1.53M<br> – ├──47｜RESTfulWebServices（11）：如何通过Spike来验证架构愿景？.pdf 949.88kb<br> – ├──48｜RESTfulWebServices（12）：如何调整接口和架构愿景？.md 1.72kb<br> – ├──48｜RESTfulWebServices（12）：如何调整接口和架构愿景？.mp3 1.42M<br> – ├──48｜RESTfulWebServices（12）：如何调整接口和架构愿景？.pdf 1.26M<br> – ├──49｜RESTfulWebService（13）：如何SpikeSub-ResourceLocator？.md 1.69kb<br> – ├──49｜RESTfulWebService（13）：如何SpikeSub-ResourceLocator？.mp3 1.81M<br> – ├──49｜RESTfulWebService（13）：如何SpikeSub-ResourceLocator？.pdf 1.26M<br> – ├──50｜RESTfulWebServices（14）：分解任务与Setup测试.md 2.85kb<br> – ├──50｜RESTfulWebServices（14）：分解任务与Setup测试.mp3 1.26M<br> – ├──50｜RESTfulWebServices（14）：分解任务与Setup测试.pdf 1.28M<br> – ├──51｜RESTfulWebServices（15）：为什么选择在第一个测试之后就开始重构？.md 2.28kb<br> – ├──51｜RESTfulWebServices（15）：为什么选择在第一个测试之后就开始重构？.mp3 1.33M<br> – ├──51｜RESTfulWebServices（15）：为什么选择在第一个测试之后就开始重构？.pdf 1.72M<br> – ├──52｜RESTfulWebServices（16）：重构手法之设计方法名的名称.md 2.44kb<br> – ├──52｜RESTfulWebServices（16）：重构手法之设计方法名的名称.mp3 1.41M<br> – ├──52｜RESTfulWebServices（16）：重构手法之设计方法名的名称.pdf 2.16M<br> – ├──53｜RESTfulWebServices（17）：如何进行Spike的架构愿景细化？.md 2.42kb<br> – ├──53｜RESTfulWebServices（17）：如何进行Spike的架构愿景细化？.mp3 1.06M<br> – ├──53｜RESTfulWebServices（17）：如何进行Spike的架构愿景细化？.pdf 1.87M<br> – ├──54｜RESTfulWebServices（18）：如何实现UriTemplate的主要功能？.md 2.62kb<br> – ├──54｜RESTfulWebServices（18）：如何实现UriTemplate的主要功能？.mp3 1.34M<br> – ├──54｜RESTfulWebServices（18）：如何实现UriTemplate的主要功能？.pdf 1.78M<br> – ├──55｜RESTfulWebServices（19）：如何更有效地构造测试数据？.md 3.95kb<br> – ├──55｜RESTfulWebServices（19）：如何更有效地构造测试数据？.mp3 1.17M<br> – ├──55｜RESTfulWebServices（19）：如何更有效地构造测试数据？.pdf 1.72M<br> – ├──56｜RESTfulWebServices（20）：为什么要通过测试的方法来驱动出代码结构？.md 2.12kb<br> – ├──56｜RESTfulWebServices（20）：为什么要通过测试的方法来驱动出代码结构？.mp3 1.43M<br> – ├──56｜RESTfulWebServices（20）：为什么要通过测试的方法来驱动出代码结构？.pdf 1.59M<br> – ├──57｜RESTfulWebServices（21）：按照三角法，该如何增加新的测试案例？.md 3.18kb<br> – ├──57｜RESTfulWebServices（21）：按照三角法，该如何增加新的测试案例？.mp3 1.48M<br> – ├──57｜RESTfulWebServices（21）：按照三角法，该如何增加新的测试案例？.pdf 1.61M<br> – ├──58｜RESTfulWebServices（22）：重构还是继续完成功能？.md 4.09kb<br> – ├──58｜RESTfulWebServices（22）：重构还是继续完成功能？.mp3 1.74M<br> – ├──58｜RESTfulWebServices（22）：重构还是继续完成功能？.pdf 2.25M<br> – ├──59｜RESTfulWebServices（23）：如何构造测试数据？.md 4.34kb<br> – ├──59｜RESTfulWebServices（23）：如何构造测试数据？.mp3 1.16M<br> – ├──59｜RESTfulWebServices（23）：如何构造测试数据？.pdf 1.72M<br> – ├──60｜RESTfulWebServices（24）：RootResource的测试要如何改造？.md 5.40kb<br> – ├──60｜RESTfulWebServices（24）：RootResource的测试要如何改造？.mp3 1.15M<br> – ├──60｜RESTfulWebServices（24）：RootResource的测试要如何改造？.pdf 1023.15kb<br> – ├──61｜RESTfulWebServices（25）：如何重构DefaultResourceRouter中的Result结构？.md 9.84kb<br> – ├──61｜RESTfulWebServices（25）：如何重构DefaultResourceRouter中的Result结构？.mp3 1.19M<br> – ├──61｜RESTfulWebServices（25）：如何重构DefaultResourceRouter中的Result结构？.pdf 2.06M<br> – ├──62｜RESTfulWebServices（26）：如何继续划分ResourceLocator的任务？.md 8.27kb<br> – ├──62｜RESTfulWebServices（26）：如何继续划分ResourceLocator的任务？.mp3 1.74M<br> – ├──62｜RESTfulWebServices（26）：如何继续划分ResourceLocator的任务？.pdf 2.49M<br> – ├──63｜RESTfulWebServices（27）：如何通过重构修改接口？.md 8.88kb<br> – ├──63｜RESTfulWebServices（27）：如何通过重构修改接口？.mp3 1.70M<br> – ├──63｜RESTfulWebServices（27）：如何通过重构修改接口？.pdf 2.41M<br> – ├──64｜RESTfulWebServices（28）：如何重构Resource、SubResource等接口与实现？.md 10.01kb<br> – ├──64｜RESTfulWebServices（28）：如何重构Resource、SubResource等接口与实现？.mp3 1.25M<br> – ├──64｜RESTfulWebServices（28）：如何重构Resource、SubResource等接口与实现？.pdf 1.56M<br> – ├──65｜RESTfulWebServices（29）：后续任务将要如何划分与实现？.md 9.46kb<br> – ├──65｜RESTfulWebServices（29）：后续任务将要如何划分与实现？.mp3 3.95M<br> – ├──65｜RESTfulWebServices（29）：后续任务将要如何划分与实现？.pdf 2.01M<br> – ├──66｜RESTfulWebServices（30）：什么情况下应该使用行为验证？.md 9.07kb<br> – ├──66｜RESTfulWebServices（30）：什么情况下应该使用行为验证？.mp3 3.92M<br> – ├──66｜RESTfulWebServices（30）：什么情况下应该使用行为验证？.pdf 2.13M<br> – ├──67｜RESTfulWebServices（31）：对于option的测试策略应该是怎样的？.md 9.68kb<br> – ├──67｜RESTfulWebServices（31）：对于option的测试策略应该是怎样的？.mp3 1.55M<br> – ├──67｜RESTfulWebServices（31）：对于option的测试策略应该是怎样的？.pdf 1.89M<br> – ├──68｜RESTfulWebServices（32）：目前代码中的一个重大Bug是什么？.md 10.95kb<br> – ├──68｜RESTfulWebServices（32）：目前代码中的一个重大Bug是什么？.mp3 1.27M<br> – ├──68｜RESTfulWebServices（32）：目前代码中的一个重大Bug是什么？.pdf 1.61M<br> – ├──69｜RESTfulWebServices（33）：如何拆分对于injection部分的需求？.md 11.40kb<br> – ├──69｜RESTfulWebServices（33）：如何拆分对于injection部分的需求？.mp3 1.45M<br> – ├──69｜RESTfulWebServices（33）：如何拆分对于injection部分的需求？.pdf 1.90M<br> – ├──70｜RESTfulWebServices（34）：在当前代码结构下，要如何进行重构？.md 12.37kb<br> – ├──70｜RESTfulWebServices（34）：在当前代码结构下，要如何进行重构？.mp3 1.69M<br> – ├──70｜RESTfulWebServices（34）：在当前代码结构下，要如何进行重构？.pdf 2.26M<br> – ├──71｜RESTfulWebServices（35）：如何将测试改为动态测试？.md 13.14kb<br> – ├──71｜RESTfulWebServices（35）：如何将测试改为动态测试？.mp3 1.48M<br> – ├──71｜RESTfulWebServices（35）：如何将测试改为动态测试？.pdf 2.33M<br> – ├──72｜RESTfulWebServices（36）：在现有结构下，如何支持转换构造函数？.md 13.37kb<br> – ├──72｜RESTfulWebServices（36）：在现有结构下，如何支持转换构造函数？.mp3 914.40kb<br> – ├──72｜RESTfulWebServices（36）：在现有结构下，如何支持转换构造函数？.pdf 1.95M<br> – ├──73｜RESTfulWebServices（37）：再增加converter方法时，步骤有什么不同？.md 14.41kb<br> – ├──73｜RESTfulWebServices（37）：再增加converter方法时，步骤有什么不同？.mp3 1.12M<br> – ├──73｜RESTfulWebServices（37）：再增加converter方法时，步骤有什么不同？.pdf 2.30M<br> – ├──74｜RESTfulWebServices（38）：如何提取方法调用部分？.md 15.29kb<br> – ├──74｜RESTfulWebServices（38）：如何提取方法调用部分？.mp3 1.05M<br> – ├──74｜RESTfulWebServices（38）：如何提取方法调用部分？.pdf 2.60M<br> – ├──75｜RESTfulWebServices（39）：如何使用继承的方式来复用测试？.md 11.18kb<br> – ├──75｜RESTfulWebServices（39）：如何使用继承的方式来复用测试？.mp3 1.34M<br> – ├──75｜RESTfulWebServices（39）：如何使用继承的方式来复用测试？.pdf 2.22M<br> – ├──76｜RESTfulWebServices（40）：如何开展有效的集成测试？.md 11.10kb<br> – ├──76｜RESTfulWebServices（40）：如何开展有效的集成测试？.mp3 1.54M<br> – ├──76｜RESTfulWebServices（40）：如何开展有效的集成测试？.pdf 1.95M<br> – ├──77｜RESTfulWebServices（41）：对于资源的访问，我们需要补充哪些相关功能？.md 11.17kb<br> – ├──77｜RESTfulWebServices（41）：对于资源的访问，我们需要补充哪些相关功能？.mp3 979.56kb<br> – ├──77｜RESTfulWebServices（41）：对于资源的访问，我们需要补充哪些相关功能？.pdf 1.63M<br> – ├──78｜RESTfulWebServices（42）：项目总结与回顾.md 11.37kb<br> – ├──78｜RESTfulWebServices（42）：项目总结与回顾.mp3 2.40M<br> – ├──78｜RESTfulWebServices（42）：项目总结与回顾.pdf 2.20M<br> – ├──79｜线段编辑器：架构思路与任务拆分.md 2.18kb<br> – ├──79｜线段编辑器：架构思路与任务拆分.mp3 2.39M<br> – ├──79｜线段编辑器：架构思路与任务拆分.pdf 1.66M<br> – ├──80｜LineEditor（2）：如何重构生成与更新锚点控制点的逻辑？.md 2.28kb<br> – ├──80｜LineEditor（2）：如何重构生成与更新锚点控制点的逻辑？.mp3 1.16M<br> – ├──80｜LineEditor（2）：如何重构生成与更新锚点控制点的逻辑？.pdf 1023.24kb<br> – ├──81｜结束语：掌握TDD的那天，我才成为了可靠高效的职业程序员.md 5.45kb<br> – ├──81｜结束语：掌握TDD的那天，我才成为了可靠高效的职业程序员.mp3 2.29M<br> – ├──81｜结束语：掌握TDD的那天，我才成为了可靠高效的职业程序员.pdf 1.01M<br> – ├──代码评点01｜不同语言TDD的节奏有何不同？.md 1.79kb<br> – ├──代码评点01｜不同语言TDD的节奏有何不同？.mp3 1.75M<br> – ├──代码评点01｜不同语言TDD的节奏