马士兵 【Java多线程与高并发】从入门到精髓

全网it学习资源共享学习<br>全网课程都有，欢迎私聊<br>微信：jerryttom<br>

├──001-马士兵2023最新MCA3.0版Java架构师课.mp4 72.68M<br> ├──002-【synchonized锁01】什么是CAS？.mp4 15.59M<br> ├──003-【synchonized锁02】CAS在新的JUC包里有哪些运用？.mp4 28.84M<br> ├──004-【synchonized锁03】用户态与内核态.mp4 11.16M<br> ├──005-【synchonized锁04】对象的内存布局.mp4 27.39M<br> ├──006-【synchonized锁05】锁升级过程.mp4 47.92M<br> ├──007-【synchonized锁06】锁的细节1：锁重入.mp4 28.91M<br> ├──008-【synchonized锁07】锁的细节2：偏向锁启动与偏向锁未启动.mp4 30.46M<br> ├──009-【synchonized锁08】锁降级过程.mp4 2.32M<br> ├──010-【synchonized锁09】synchonized实现过程.mp4 23.31M<br> ├──011-【线程&amp;synchonized锁10】什么是锁？.mp4 10.40M<br> ├──012-【线程&amp;synchonized锁11】互斥锁.mp4 55.90M<br> ├──013-【线程&amp;synchonized锁12】synchronized.mp4 18.74M<br> ├──014-【线程&amp;synchonized锁13】markword.mp4 11.86M<br> ├──015-【线程&amp;synchonized锁14】CAS.mp4 67.41M<br> ├──016-【线程&amp;synchonized锁15】自旋锁.mp4 9.36M<br> ├──017-【线程&amp;synchonized锁16】锁升级初步.mp4 29.81M<br> ├──018-【线程&amp;synchonized锁17】小结.mp4 65.13M<br> ├──019-【线程&amp;synchonized锁18】计算机组成.mp4 53.53M<br> ├──020-【线程&amp;synchonized锁19】多核cpu.mp4 16.11M<br> ├──021-【线程&amp;synchonized锁20】cacheline的概念伪共享).mp4 22.84M<br> ├──022-【线程&amp;synchonized锁21】CacheLinePadding代码讲解).mp4 31.19M<br> ├──023-【线程&amp;synchonized锁22】多线程可见性问题.mp4 11.55M<br> ├──024-【线程&amp;synchonized锁23】Disorder代码讲解.mp4 26.24M<br> ├──025-【线程&amp;synchonized锁24】NoVisibility代码讲解.mp4 19.93M<br> ├──026-【线程&amp;synchonized锁25】汇编码解读.mp4 22.78M<br> ├──027-【线程&amp;synchonized锁26】DCL单列要不要加volatile1.mp4 25.88M<br> ├──028-【线程&amp;synchonized锁27】DCL单列要不要加volatile2.mp4 41.61M<br> ├──029-【线程&amp;synchonized锁28】解决乱序.mp4 31.29M<br> ├──030-【线程&amp;synchonized锁29】Jvm内存屏障.mp4 15.35M<br> ├──031-【线程&amp;synchonized锁30】volatile实现细节.mp4 5.54M<br> ├──032-【多线程&amp;高并发31】为什么阿里京东都喜欢问JUC？.mp4 58.59M<br> ├──033-【多线程&amp;高并发32】为什么CAS和AQS是JUC的核心？.mp4 72.30M<br> ├──034-【多线程&amp;高并发33】ReentrantLock适用于什么场景？.mp4 71.51M<br> ├──035-【多线程&amp;高并发34】原生锁支持（LockSupport）适用于什么场景？.mp4 87.46M<br> ├──036-【多线程&amp;高并发35】各种同步器在大厂面试中的综合运用怎么做？.mp4 103.78M<br> ├──037-【多线程&amp;高并发36】从CPU架构的角度理解底层高并发的构成.mp4 254.83M<br> ├──038-【多线程&amp;高并发37】为什么百度腾讯喜欢跟你聊线程池？.mp4 70.52M<br> ├──039-【多线程&amp;高并发38】JDK有哪些直接可用的线程池？.mp4 88.76M<br> ├──040-【多线程&amp;高并发39】线程池如果需要自定义，有哪些参数可以定义？.mp4 83.90M<br> ├──041-【多线程&amp;高并发40】生产环境中的线程池如何监控？.mp4 132.51M<br> ├──042-【多线程&amp;高并发41】线程池有哪些在实际中的应用场景？.mp4 106.31M<br> ├──043-【多线程&amp;高并发42】面向未来，学习路线指引与职业规划指导.mp4 228.41M<br> ├──044-【并发的本质43】计算机组成原理-现代CPU架构带来的可见性难题详解.mp4 46.04M<br> ├──045-【并发的本质44】掌握并发底层原理.mp4 324.07M<br> ├──046-【并发的本质45】探寻锁的本质.mp4 242.10M<br> ├──047-【并发的本质46】cache line的概念-缓存行对齐、伪共享.mp4 29.24M<br> ├──048-【并发的本质47】缓存行填充的编程技巧.mp4 49.89M<br> ├──049-【并发的本质48】有序性带来的this溢出问题.mp4 59.37M<br> ├──050-【并发的本质49】有序性带来的半程对象问题.mp4 20.12M<br> ├──051-【并发的本质50】JAVA靠什么解决可见性和有序性.mp4 24.25M<br> ├──052-【并发的本质51】写BUFFER的底层性能优化问题（首次公开）.mp4 122.63M<br> ├──053-【并发的本质52】锁的本质到底是个啥？.mp4 26.43M<br> ├──054-【并发的本质53】锁在JAVA中如何实现.mp4 49.29M<br> ├──055-【并发的本质54】锁概念解析.mp4 12.33M<br> ├──056-【并发的本质55】详解自旋锁概念.mp4 108.23M<br> ├──057-【并发的本质56】JAVA中的锁优化，锁升级详解.mp4 88.64M<br> ├──058-【ReentrantLock源码-57】ReentrantLock简介（整套内容介绍）.mp4 13.53M<br> ├──059-【ReentrantLock源码-58】ReentrantLock简单分析lock方法.mp4 22.21M<br> ├──060-【ReentrantLock源码-59】AQS介绍.mp4 16.72M<br> ├──061-【ReentrantLock源码-60】lock方法源码.mp4 9.02M<br> ├──062-【ReentrantLock源码-61】acquire方法源码.mp4 22.40M<br> ├──063-【ReentrantLock源码-62】tryAcquire方法.mp4 26.79M<br> ├──064-【ReentrantLock源码-63】addWaiter方法.mp4 26.48M<br> ├──065-【ReentrantLock源码-64】acqureQueued方法（上）.mp4 32.55M<br> ├──066-【ReentrantLock源码-65】acqureQueued方法（下）.mp4 36.63M<br> ├──067-【ReentrantLock源码-66】unlock方法分析.mp4 12.59M<br> ├──068-【ReentrantLock源码-67】release方法分析.mp4 41.92M<br> ├──069-【线程池源码68】并发课程介绍-线程池源码.mp4 20.89M<br> ├──070-【线程池源码69】应用方式.mp4 17.93M<br> ├──071-【线程池源码70】核心参数.mp4 28.71M<br> ├──072-【线程池源码71】线程池执行流程分析.mp4 16.98M<br> ├──073-【线程池源码72】线程池ctl属性分析.mp4 37.72M<br> ├──074-【线程池源码73】线程池状态.mp4 16.64M<br> ├──075-【线程池源码74】execute方法.mp4 41.16M<br> ├──076-【线程池源码75】addWorker方法-状态&amp;数量判断.mp4 27.37M<br> ├──077-【线程池源码76】addWorker方法-添加&amp;启动工作线程.mp4 52.09M<br> ├──078-【线程池源码77】Worker对象简单认知.mp4 31.60M<br> ├──079-【线程池源码78】runWorker方法分析.mp4 62.90M<br> ├──080-【线程池源码79】getTask方法分析.mp4 70.89M<br> ├──081-【线程池源码80】processWorkerExit方法分析.mp4 49.27M<br> ├──082-【基础篇01】线程的概念.mp4 13.65M<br> ├──083-【基础篇02】线程的启动方式.mp4 6.69M<br> ├──084-【基础篇03】线程的3个方法.mp4 10.68M<br> ├──085-【基础篇04】线程的状态.mp4 16.65M<br> ├──086-【基础篇05】锁的概念.mp4 13.25M<br> ├──087-【基础篇06】锁的特性.mp4 3.83M<br> ├──088-【基础篇07】设计小程序验证锁的问题.mp4 22.86M<br> ├──089-【基础篇08】锁的可重入属性.mp4 7.69M<br> ├──090-【基础篇09】异常跟锁.mp4 7.04M<br> ├──091-【基础篇10】锁的底层实现.mp4 22.10M<br> ├──092-【基础篇11】Volatile保证线程可见性.mp4 18.52M<br> ├──093-【基础篇12】Volatile禁止指令重排序.mp4 43.69M<br> ├──094-【基础篇13】Volatile不能保证原子性.mp4 7.99M<br> ├──095-【基础篇14】synchronized优化.mp4 9.68M<br> ├──096-【基础篇15】简单回顾.mp4 5.00M<br> ├──097-【基础篇16】CAS(1).mp4 20.41M<br> ├──098-【基础篇17】CAS(2).mp4 42.26M<br> ├──099-【基础篇18】LongAdder.mp4 27.86M<br> ├──100-【基础篇19】间接性复习.mp4 2.66M<br> ├──101-【基础篇20】ReentrantLock.mp4 48.66M<br> ├